1장: 객체란?
=====
## 목차
1. [CONTENTS](#CONTENTS)
2. [참고](#참고)

## CONTENTS
* 객체란?
	* [추상화 과정](#추상화-과정)
	* [객체는 인터페이스를 갖는다](#객체는-인터페이스를-갖는다)
	* [객체는 서비스를 제공한다](#객체는-서비스를-제공한다)
	* [구현부분 감추기](#구현부분-감추기)
	* [구현부분의 재사용](#구현부분의-재사용)
	* [상속](#상속)
		* Is-a와 Is-like-a 관계
	* 다형성의 개념과 구현

- - -
### 추상화 과정
모든 프로그래밍 언어에서는 추상화(abstraction)를 제공한다. 이는 우리가 해결할 수 있는 문제의 복잡도와 직접적인 관련이 있다.

* 추상화(abstraction)
	* 종류(kind): 추상화하려는 것이 무엇인가?
		* 프로그래밍 방법론 이전
			* 어셈블리어: 근간이 되는 컴퓨터를 추상화
			* 명령형(imperative) 언어(ex. Fortran, BASIC, C): 어셈블리어를 추상화
				* 어셈블리어에 비해 많이 진보했지만 여전히 추상화 수준이 낮아서 해결하려는 문제 구조보다는 여전히 컴퓨터 구조의 관점에서 생각 필요
					* 즉, 문제 모델(업무 영역)과 머신 모델(컴퓨터 영역) 간의 관계를 프로그래머가 만들어주어야 함
				* 이런 연관 작업에 대한 부분이 작성하기 어렵고 유지보수 비용이 많이 들어가기 때문에 프로그래밍 방법론 분야가 생겨남
		* 프로그래밍 방법론 이후
			* 머신 모델로 만드는 다른 방도(프로그래머가 직접 작성하지 않음)는 우리가 문제 모델을 만들면 프로그래밍 언어에서 머신 모델로 만들도록 하는 것
			* 초창기 언어들
				* 예
					* LISP: 모든 문제들이 궁극적으로 목록 구조라는 관점
					* APL: 모든 문제들이 알고리즘이라는 관점
					* PROLOG: 모든 문제들이 일련의 연속된 판단이라는 관점
				* 문제점
					* 이 접근법들은 특정 부류의 문제에 대해선 좋은 해법이 될 수 있음
					* 하지만 제약 기반(constraint-based)의 프로그래밍을 하기 위해 만들어졌으므로, 그 문제 영역을 벗어나면 부적합
			* 객체지향 접근방식
				* 문제 영역의 요소들을 프로그래머가 표현할 수 있도록 함
					* 표현 방법이 보편적이라 프로그래머는 특정 타입의 문제에 제한되지 않음
				* 객체(Object)
					* 문제 영역의 요소들 및 그것을 해결 영역에 표현한 것을 총칭
					* 문제 영역에 대응되는 객체 없이 해결 영역에만 존재하는 객체도 필요
				* OOP
					* 아직은 컴퓨터와 관련되지만 해법이 실행된 컴퓨터의 관점이 아닌 문제의 관점
						* 즉, 각 객체는 마치 컴퓨터(상태와 오퍼레이션을 가짐)처럼 보임
							* 오퍼레이션(operation): 외부의 요청으로 수행하는 일
	* 특성(quality)

아래는 앨런 케이가 요약한 최초의 성공적 객체지향 언어인 스몰토크(smalltalk)의 다섯 가지 기본 특성이다. 이는 객체지향 프로그래밍에 대한 기본 원리를 나타낸다.

* 모든 것이 객체다:
	* 객체를 변수라고 생각하자. 데이터를 저장한다.
	* 그러나 우리는 객체에게 '요청(request)'을 하여 객체 자신이 갖는 오퍼레이션을 수행하도록 요구할 수 있다.
* 프로그램은 여러 가지의 객체들로 구성되고, 각 객체들은 상호간에 메시지를 보내어 일을 수행한다:
	* 객체에게 일을 요청하려면 '메시지를 보낸다'.
	* 더 구체적으로 말하면 객체가 갖는 메소드(method)를 호출하는 것을 메시지라고 생각할 수 있다.
* 각 객체는 다른 객체들로 이루어진 자신의 메모리를 갖는다:
	* 달리 말해서, 기존 객체들을 포함시켜 새로운 종류의 객체를 만든다.
	* 따라서 포함된 객체들의 단순화로 복잡함을 감추게 되므로 복잡도가 높은 프로그램을 만들 수 있다.
* 모든 객체는 자신의 타입(type)이 있다:
	* 객체는 클래스(class)의 인스턴스(instance)이다.
	* 여기서 '클래스'는 '타입'과 같은 의미이다.
	* 클래스를 특징짓는 가장 중요한 것은 '그 클래스에게 무슨 메시지를 보낼 수 있는가?' 즉, 무슨 일을 할 수 있는가이다.
* 특정 타입에 속하는 모든 객체는 동일한 메시지를 받을 수 있다:
	* '원(circle)' 타입의 객체는 또한 '도형(shape)' 타입의 객체이므로, 특정 원 객체는 도형의 메시지를 받을 수 있다.
	* 도형 객체들에게 메시지를 보내면 자동적으로 도형 부류에 적합한 어떤 일을 처리하는 코드를 작성할 수 있다는 의미이다.
	* 이것을 '대체성(substitutability)'이라고 하며, OOP의 가장 강력한 개념 중 하나이다.

Grady Booch는 훨씬 더 간결하게 객체를 기술하고 있다.

> 객체는 상태(state)와 행동(behavior) 및 정체성(identity)을 갖는다.

즉, 객체는 내부 데이터(상태로 되는)와 메소드(행동을 수행하는)를 가질 수 있으며, 각 객체는 모든 다른 객체와 고유하게 식별될 수 있다(구체적으로 말해서 각 객체는 고유한 메모리 번지를 갖는다)는 의미이다. 추가로 고유한 메모리 번지라는 표현은 다소 제한적이다. 왜냐하면 객체들이 서로 다른 컴퓨터와 번지 공간에 존재할 수 있으며, 디스크에 저장될 수도 있기 때문이다. 이 경우 객체의 정체성은 메모리 번지가 아닌 다른 것으로 결정되어야 한다.
	
##### [목차로 이동](#목차)

### 객체는 인터페이스를 갖는다
* class 키워드
	* 모든 객체는 고유하면서도 또한 공통적인 특성과 행동을 갖는 특정 클래스에 속함
	* 프로그램 실행 중에 상태만 변할 뿐 동일한 객체들은 '객체의 클래스'로 분류하였는데, 바로 여기서 class 키워드가 도입
		* 이러한 개념은 최초의 객체지향 언어인 [Simula-67](#Simula-67)에서 그대로 사용
* 추상 데이터 타입(클래스) 만들기: OOP의 기본 개념
	* 추상 데이터 타입은 내장 타입(built-in type)과 거의 똑같이 동작
	* 즉, 추상 데이터 타입의 변수를 생성(A)하여 조작(B)할 수 있음
		* A: 객체지향 용어로 객체 또는 인스턴스라고 함
		* B: 메시지나 요청을 보낸다고 하는데, 메시지를 보내면 객체가 자신의 할 일을 판단함
	* 각 클래스의 멤버(변수와 메소드)는 그 클래스의 객체들이 공유함
* 클래스는 하나의 데이터 타입
	* OOP에서 우리가 하는 것은 새로운 데이터 타입, 즉 class를 만드는 것
	* 동일한 속성(데이터 요소)과 동일한 행동(기능성)을 갖는 객체들을 나타낸 것이 클래스이므로, 클래스는 하나의 데이터 타입
		* 즉, 'type'은 'class'로, 'class'는 'type'으로 [생각](#타입과-클래스)
* 인터페이스란?
	* 우리에게 유용한 일(B)을 해주는 객체를 어떻게 획득해야 할까?
		* 거래를 완료한다, 화면상에 무언가를 그린다, 스위치를 켠다 등과 같은 일을 객체가 수행하도록 요청하는 방법이 필요
		* 이때 각 객체는 특정 요청만을 해 줄 수 있음
	* 우리가 객체에게 할 수 있는 요청을 그 객체의 인터페이스(interface)라고 하며, 그것을 결정하는 것이 타입
		* 예
			* [클래스 다이어그램](#클래스-다이어그램)  
				<img src="../img/light_bulb_uml.jpg" width="350" height="200"></br>
			* 코드  
				```java
				Light it = new Light();
				it.on();
				```
* 구현이란?
	* 인터페이스는 특정 객체에게 할 수 있는 요청을 의미
	* 그렇다면, 그러한 요청을 충족하는 코드가 어딘가에 존재해야 함
	* 숨겨진 데이터와 그 코드를 일컬어 구현(Implementation)이라고 지칭
	
##### [목차로 이동](#목차)

#### Simula-67
이름에서도 알 수 있듯, Simula 언어는 전형적인 '은행 금전출납원'과 같은 업무의 시뮬레이션을 개발하기 위해 만들어졌다. 거기에는 다수의 금전 출납원, 고객, 계정, 거래, 화폐단위, 즉 많은 '객체'들이 존재하였다. 프로그램 실행 중에 상태만 변할 뿐 동일한 객체들은 '객체의 클래스'로 분류하였는데, 바로 여기서 class 키워드가 도입되었다. 추상 데이터 타입(클래스)을 만드는 것이 OOP의 기본 개념이다.

##### [목차로 이동](#목차)

#### 타입과 클래스
타입은 인터페이스를 결정하고, 클래스는 그 인터페이스의 특정 구현(같은 인터페이스를 서로 다른 클래스에서 달리 구현할 수 있기 때문이다)이라고 구분하는 사람들이 있다.

##### [목차로 이동](#목차)

#### 클래스 다이어그램
클래스 다이어그램은 UML(Unified Modeling Language) 형식을 따른다. 각 클래스는 사각형으로 나타내며, 제일 위쪽에는 타입(클래스) 명을, 중간 부분에는 데이터 멤버를, 그리고 제일 아래쪽에는 메소드(이 객체에 속한 함수로서 객체에게 보내는 메시지를 받는다)를 표시한다. UML 설계 다이어그램들에서는 클래스 명과 공용(public) 메소드만을 나타내는 경우가 흔히 있는데, 이때는 위와 같이 가운데 부분이 나타나지 않는다.

##### [목차로 이동](#목차)

### 객체는 서비스를 제공한다
프로그램을 개발 또는 파악하고자 할 때 가장 좋은 방법 중 하나는 객체를 '서비스 제공자'로 생각하는 것이다. 우리 프로그램 자체는 사용자에게 서비스를 제공할 것이며, 이것은 다른 객체들이 제공하는 서비스를 사용함으로써 이루어진다.

우리의 목표는 문제 해결을 위해 이상적인 서비스를 제공하는 객체들을 만드는(또는 더 바람직하게는 기존의 코드 라이브러리에서 찾는) 것이다.

##### [목차로 이동](#목차)

### 구현부분 감추기
작업 분야를 클래스 작성자(새로운 데이터 타입을 만드는 사람)와 클라이언트 프로그래머(그 데이터 타입을 자신의 애플리케이션에 사용하는 클래스 소비자)로 구분하면 유용하다. 이 경우 우리가 라이브러리를 작성하면 우리는 클라이언트 프로그래머(그 역시 프로그래머인)와 관계가 생긴다. 어떤 관계에서든 개입된 모든 당사자들이 지켜야 할 경계를 갖는 것이 중요하다. 그러나 만일 클래스의 모든 멤버(데이터와 메소드)를 누구나 사용할 수 있다면, 클라이언트 프로그래머가 그 클래스에 대해 무엇이든 할 수 있을 것이고 규칙(경계를 지키는)을 지키도록 할 방법이 없다. 따라서 접근 제어(access control)가 필요하고, 그 이유는 아래와 같다.

1. 클라이언트 프로그래머가 손대서는 안 될 부분(클래스의 내부 작업에 필요한 부분으로서 사용자가 자신들의 문제를 해결하는 데 필요한 인터페이스에 속하지 않는)을 건드리지 못하게 하는 것이다.
	* 실제로 이것이 클라이언트 프로그래머에 대한 서비스이다.
2. 클라이언트 프로그래머에게 어떤 영향을 줄지 걱정하지 않고 라이브러리 설계자가 클래스 내부를 변경할 수 있다는 것이다.
	* 만일 인터페이스와 구현 부분이 명확하게 구분되고 잘 지켜져 있다면 쉽게 할 수 있을 것이다.

##### [목차로 이동](#목차)

### 구현부분의 재사용
코드의 재사용은 객체지향 프로그래밍 언어가 제공하는 최대 장점 중 하나이다. 그러나 이러한 재사용은 많은 사람들이 바라듯 쉽게 얻어지는 것이 결코 아니다. 이상적으로는, 일단 클래스가 작성되어 테스트까지 완료되면 유용한 단위 코드가 되어야 함에도 말이다.

한편 클래스를 재사용하는 방법은 아래와 같다.

1. 클래스의 객체를 바로 사용하는 것
2. 컴포지션(composition)
	* 클래스의 객체를 새로운 클래스 내부에 포함시키는 것
		* 즉 기존 클래스들을 조립(compose)하여 새로운 클래스를 만드는 것
		* 멤버 객체의 생성이라고 함
	* 'has-a' 관계(ex. 자동차는 엔진을 갖는다)
	* cf. 집합연관(aggregation)
		* 컴포지션이 동적으로 생기는 것
3. [상속](#상속)

이 세 가지 방법 중 흔히 컴포지션과 상속을 많이 비교하는데, 책에선 다음과 같이 언급하고 있다.

> 새로운 클래스를 생성할 때는 컴포지션을 우선적으로 고려해야 한다. 더 쉽고 유연성이 좋기 때문이다.

> * 기존의 클라이언트 코드에 영향을 주지 않고 그러한 멤버들을 변경할 수 있게 해준다.
> 	* 새로운 

##### [목차로 이동](#목차)

### 상속


##### [목차로 이동](#목차)

## 참고


##### [목차로 이동](#목차)