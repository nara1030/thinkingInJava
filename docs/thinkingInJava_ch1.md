1장: 객체란?
=====
## 목차
1. [CONTENTS](#CONTENTS)
2. [참고](#참고)

## CONTENTS
* 객체란?
	* [추상화 과정](#추상화-과정)
	* [객체는 인터페이스를 갖는다](#객체는-인터페이스를-갖는다)
	* [객체는 서비스를 제공한다](#객체는-서비스를-제공한다)
	* [구현부분 감추기](#구현부분-감추기)
	* 구현부분의 재사용
	* 상속
		* Is-a와 Is-like-a 관계
	* 다형성의 개념과 구현

- - -
### 추상화 과정
모든 프로그래밍 언어에서는 추상화(abstraction)를 제공한다. 이는 우리가 해결할 수 있는 문제의 복잡도와 직접적인 관련이 있다.

* 추상화(abstraction)
	* 종류(kind): 추상화하려는 것이 무엇인가?
		* 프로그래밍 방법론 이전
			* 어셈블리어: 근간이 되는 컴퓨터를 추상화
			* 명령형(imperative) 언어(ex. Fortran, BASIC, C): 어셈블리어를 추상화
				* 어셈블리어에 비해 많이 진보했지만 여전히 추상화 수준이 낮아서 해결하려는 문제 구조보다는 여전히 컴퓨터 구조의 관점에서 생각 필요
					* 즉, 문제 모델(업무 영역)과 머신 모델(컴퓨터 영역) 간의 관계를 프로그래머가 만들어주어야 함
				* 이런 연관 작업에 대한 부분이 작성하기 어렵고 유지보수 비용이 많이 들어가기 때문에 프로그래밍 방법론 분야가 생겨남
		* 프로그래밍 방법론 이후
			* 머신 모델로 만드는 다른 방도(프로그래머가 직접 작성하지 않음)는 우리가 문제 모델을 만들면 프로그래밍 언어에서 머신 모델로 만들도록 하는 것
			* 초창기 언어들
				* 예
					* LISP: 모든 문제들이 궁극적으로 목록 구조라는 관점
					* APL: 모든 문제들이 알고리즘이라는 관점
					* PROLOG: 모든 문제들이 일련의 연속된 판단이라는 관점
				* 문제점
					* 이 접근법들은 특정 부류의 문제에 대해선 좋은 해법이 될 수 있음
					* 하지만 제약 기반(constraint-based)의 프로그래밍을 하기 위해 만들어졌으므로, 그 문제 영역을 벗어나면 부적합
			* 객체지향 접근방식
				* 문제 영역의 요소들을 프로그래머가 표현할 수 있도록 함
					* 표현 방법이 보편적이라 프로그래머는 특정 타입의 문제에 제한되지 않음
				* 객체(Object)
					* 문제 영역의 요소들 및 그것을 해결 영역에 표현한 것을 총칭
					* 문제 영역에 대응되는 객체 없이 해결 영역에만 존재하는 객체도 필요
				* OOP
					* 아직은 컴퓨터와 관련되지만 해법이 실행된 컴퓨터의 관점이 아닌 문제의 관점
						* 즉, 각 객체는 마치 컴퓨터(상태와 오퍼레이션을 가짐)처럼 보임
							* 오퍼레이션(operation): 외부의 요청으로 수행하는 일
	* 특성(quality)

아래는 앨런 케이가 요약한 최초의 성공적 객체지향 언어인 스몰토크(smalltalk)의 다섯 가지 기본 특성이다. 이는 객체지향 프로그래밍에 대한 기본 원리를 나타낸다.

* 모든 것이 객체다:
	* 객체를 변수라고 생각하자. 데이터를 저장한다.
	* 그러나 우리는 객체에게 '요청(request)'을 하여 객체 자신이 갖는 오퍼레이션을 수행하도록 요구할 수 있다.
* 프로그램은 여러 가지의 객체들로 구성되고, 각 객체들은 상호간에 메시지를 보내어 일을 수행한다:
	* 객체에게 일을 요청하려면 '메시지를 보낸다'.
	* 더 구체적으로 말하면 객체가 갖는 메소드(method)를 호출하는 것을 메시지라고 생각할 수 있다.
* 각 객체는 다른 객체들로 이루어진 자신의 메모리를 갖는다:
	* 달리 말해서, 기존 객체들을 포함시켜 새로운 종류의 객체를 만든다.
	* 따라서 포함된 객체들의 단순화로 복잡함을 감추게 되므로 복잡도가 높은 프로그램을 만들 수 있다.
* 모든 객체는 자신의 타입(type)이 있다:
	* 객체는 클래스(class)의 인스턴스(instance)이다.
	* 여기서 '클래스'는 '타입'과 같은 의미이다.
	* 클래스를 특징짓는 가장 중요한 것은 '그 클래스에게 무슨 메시지를 보낼 수 있는가?' 즉, 무슨 일을 할 수 있는가이다.
* 특정 타입에 속하는 모든 객체는 동일한 메시지를 받을 수 있다:
	* '원(circle)' 타입의 객체는 또한 '도형(shape)' 타입의 객체이므로, 특정 원 객체는 도형의 메시지를 받을 수 있다.
	* 도형 객체들에게 메시지를 보내면 자동적으로 도형 부류에 적합한 어떤 일을 처리하는 코드를 작성할 수 있다는 의미이다.
	* 이것을 '대체성(substitutability)'이라고 하며, OOP의 가장 강력한 개념 중 하나이다.

Grady Booch는 훨씬 더 간결하게 객체를 기술하고 있다.

> 객체는 상태(state)와 행동(behavior) 및 정체성(identity)을 갖는다.

즉, 객체는 내부 데이터(상태로 되는)와 메소드(행동을 수행하는)를 가질 수 있으며, 각 객체는 모든 다른 객체와 고유하게 식별될 수 있다(구체적으로 말해서 각 객체는 고유한 메모리 번지를 갖는다)는 의미이다. 추가로 고유한 메모리 번지라는 표현은 다소 제한적이다. 왜냐하면 객체들이 서로 다른 컴퓨터와 번지 공간에 존재할 수 있으며, 디스크에 저장될 수도 있기 때문이다. 이 경우 객체의 정체성은 메모리 번지가 아닌 다른 것으로 결정되어야 한다.
	
##### [목차로 이동](#목차)

### 객체는 인터페이스를 갖는다
* class 키워드
	* 모든 객체는 고유하면서도 또한 공통적인 특성과 행동을 갖는 특정 클래스에 속함
	* 프로그램 실행 중에 상태만 변할 뿐 동일한 객체들은 '객체의 클래스'로 분류하였는데, 바로 여기서 class 키워드가 도입
		* 이러한 개념은 최초의 객체지향 언이인 [Simula-67](#Simula-67)에서 그대로 사용
* 추상 데이터 타입(클래스) 만들기: OOP의 기본 개념
	* 추상 데이터 타입은 내장 타입(built-in type)과 거의 똑같이 동작
	* 즉, 추상 데이터 타입의 변수를 생성(A)하여 조작(B)할 수 있음
		* A: 객체지향 용어로 객체 또는 인스턴스라고 함
		* B: 메시지나 요청을 보낸다고 하는데, 메시지를 보내면 객체가 자신의 할 일을 판단함
	* 각 클래스의 멤버(변수와 메소드)는 그 클래스의 객체들이 공유함
* 클래스는 하나의 데이터 타입
	* OOP에서 우리가 하는 것은 새로운 데이터 타입, 즉 class를 만드는 것
	* 동일한 속성(데이터 요소)과 동일한 행동(기능성)을 갖는 객체들을 나타낸 것이 클래스이므로, 클래스는 하나의 데이터 타입
		* 즉, 'type'은 'class'로, 'class'는 'type'으로 생각
* 인터페이스란?
	* 우리에게 유용한 일(B)을 해주는 객체를 어떻게 획득해야 할까?
		* 거래를 완료한다, 화면상에 무언가를 그린다, 스위치를 켠다 등과 같은 일을 객체가 수행하도록 요청하는 방법이 필요
		* 각 객체는 특정 요청만을 해 줄 수 있음
	* 우리가 객체에게 할 수 있는 요청을 그 객체의 인터페이스(interface)라고 하며, 그것을 결정하는 것이 타입
		* .
##### [목차로 이동](#목차)

#### Simula-67


##### [목차로 이동](#목차)

### 객체는 서비스를 제공한다


##### [목차로 이동](#목차)

### 구현부분 감추기


##### [목차로 이동](#목차)


## 참고


##### [목차로 이동](#목차)